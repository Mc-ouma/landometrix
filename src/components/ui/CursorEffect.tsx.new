'use client';

import { useEffect, useState, useCallback, memo, useRef } from 'react';

type CursorEffectProps = {
  color?: string;
  size?: number;
  trailLength?: number;
  trailColor?: string;
  showOnMobile?: boolean;
};

// Optimization: Define outside component to avoid recreation
const DEFAULT_POSITION = { x: 0, y: 0 };

const CursorEffect = ({ 
  color = 'rgba(37, 99, 235, 0.5)', // Default is a semi-transparent blue
  size = 30,
  trailLength = 8,
  trailColor = 'rgba(59, 130, 246, 0.2)', // Default is a lighter semi-transparent blue
  showOnMobile = false,
}: CursorEffectProps) => {
  // Use refs to avoid re-renders when changing position
  const positionRef = useRef(DEFAULT_POSITION);
  const [isVisible, setIsVisible] = useState(false);
  const [trail, setTrail] = useState<Array<{ x: number, y: number }>>([]);
  const [isPointer, setIsPointer] = useState(false);
  const [shouldRender, setShouldRender] = useState(false);
  
  // Performance optimization: Use refs for handlers to avoid closures
  const handlersRef = useRef({
    updateCursorPosition: (e: MouseEvent) => {
      // Update position reference without causing re-render
      positionRef.current = { x: e.clientX, y: e.clientY };
      
      // Only update visible state if it's changing to avoid re-renders
      if (!isVisible) setIsVisible(true);
      
      // Use the local variable to reduce state updates
      const target = e.target as HTMLElement;
      const isClickable = 
        target.tagName === 'BUTTON' || 
        target.tagName === 'A' || 
        target.tagName === 'INPUT' ||
        target.tagName === 'SELECT' ||
        target.tagName === 'TEXTAREA' ||
        target.closest('button') !== null ||
        target.closest('a') !== null ||
        target.closest('input') !== null ||
        target.closest('select') !== null ||
        target.closest('textarea') !== null;
      
      if (isClickable !== isPointer) {
        setIsPointer(isClickable);
      }

      // Update trail positions more efficiently
      setTrail(prevTrail => {
        if (prevTrail.length === 0) {
          // Start the trail
          return Array(trailLength).fill({ x: e.clientX, y: e.clientY });
        } else {
          // Update trail with new position
          const newTrail = [...prevTrail, { x: e.clientX, y: e.clientY }];
          return newTrail.length > trailLength 
            ? newTrail.slice(newTrail.length - trailLength)
            : newTrail;
        }
      });
    },
    
    showCursor: () => setIsVisible(true),
    hideCursor: () => setIsVisible(false)
  });
  
  // Initialize once on mount
  useEffect(() => {
    // Skip on touch devices unless explicitly enabled
    if ('ontouchstart' in window && !showOnMobile) {
      return;
    }
    
    // Initialize with default values
    setShouldRender(true);
    
    // Hide default cursor
    document.documentElement.style.cursor = 'none';
    
    // Create a single animation frame loop for smoother animations
    let animationFrameId: number;
    
    const renderLoop = () => {
      document.addEventListener('mousemove', handlersRef.current.updateCursorPosition);
      document.addEventListener('mouseenter', handlersRef.current.showCursor);
      document.addEventListener('mouseleave', handlersRef.current.hideCursor);
      
      animationFrameId = requestAnimationFrame(renderLoop);
    };
    
    // Start the loop
    renderLoop();
    
    // Clean up
    return () => {
      document.removeEventListener('mousemove', handlersRef.current.updateCursorPosition);
      document.removeEventListener('mouseenter', handlersRef.current.showCursor);
      document.removeEventListener('mouseleave', handlersRef.current.hideCursor);
      
      cancelAnimationFrame(animationFrameId);
      
      // Restore default cursor
      document.documentElement.style.cursor = '';
    };
  }, [showOnMobile, trailLength]); // Only re-run if these props change
  
  // Skip rendering on mobile or before initialization
  if (!shouldRender || (!showOnMobile && 'ontouchstart' in window)) {
    return null;
  }
  
  const { x, y } = positionRef.current;
  
  return (
    <>
      {/* Optimize trail rendering by mapping only once */}
      {trail.map((point, index) => {
        const scale = (index / trail.length) + 0.3;
        const opacity = index / trail.length;
        
        return (
          <div
            key={index}
            className="fixed pointer-events-none z-[9999] rounded-full mix-blend-overlay transition-opacity"
            style={{
              left: `${point.x}px`,
              top: `${point.y}px`,
              width: `${size * 0.8 * scale}px`,
              height: `${size * 0.8 * scale}px`,
              backgroundColor: trailColor,
              opacity,
              transform: 'translate(-50%, -50%)',
            }}
          />
        );
      })}
      
      {/* Main cursor */}
      <div
        className={`fixed pointer-events-none z-[10000] rounded-full transition-all duration-100 ease-out ${
          isPointer ? 'scale-[0.5] mix-blend-difference' : 'scale-100 mix-blend-overlay'
        }`}
        style={{
          left: `${x}px`,
          top: `${y}px`,
          width: `${size}px`,
          height: `${size}px`,
          backgroundColor: color,
          transform: 'translate(-50%, -50%)',
          boxShadow: isPointer ? '0 0 20px 5px rgba(59, 130, 246, 0.5)' : 'none',
          opacity: isVisible ? 1 : 0,
        }}
      />
    </>
  );
};

// Export memoized component
export default memo(CursorEffect);
